#! /usr/bin/env python
#############################################################################
#
#              epm
#
# File:        $Source: /home/d/work/personal/ticker-cvs/epm/epm,v $
# Version:     $RCSfile: epm,v $ $Revision: 1.15 $
#
# COPYRIGHT_BEGIN
#
# Copyright:   (C) 2001, David Arnold.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above
#   copyright notice, this list of conditions and the following
#   disclaimer.
#
# * Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the following
#   disclaimer in the documentation and/or other materials
#   provided with the distribution.
#
# * Neither the name of the DSTC nor the names
#   of its contributors may be used to endorse or promote
#   products derived from this software without specific prior
#   written permission. 
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# COPYRIGHT_END
#############################################################################

import elvin, gtk, os, random, sha, socket, sys, time

########################################################################

# constants
RELEASE          = "0.3"
DEFAULT_STATUS   = ["Online", "Offline", "Unavailable", "Coffee"]
PROTOCOL_VERSION = 1000

# default config values
USER       = os.environ.get("USER", os.environ.get("LOGNAME", "Anonymous Coward"))
DOMAIN     = socket.gethostname()
GROUPS     = []
SUB_USERS  = []
SUB_GROUPS = []
STATUS     = []

# usage message
USAGE = """Usage: epm [options ...]

-e url             Elvin router URL.  You can specify
--elvin=url        as many URLs as you like, and they'll
                   be attempted in order.
-S scope           Scope name.  Only one can be supplied
--scope=scope      and you can't specify both a scope and
                   URLs.
-u user            User's name
--user=username
-D domain          Domain name
--domain=domain
-G file            Tickertape groups file
--groups=file
-d                 Run in daemon mode, as an edesk component
--daemon
-v                 Print the version number
--version
-h                 Print this usage information
--help

"""


########################################################################

class PresenceInfo:
    def __init__(self, nfn):

        self._time = 0
        
        self.update(nfn)
        return


    def update(self, nfn):
        """Apply a presence status notification to this buddy.

        *nfn*
        Returns  -- 1 if the user's status was updated, 0 otherwise
        
        """

        if nfn.has_key("Status"):
            update_time = time.time() - float(nfn["Status-Duration"])

            if update_time > self._time:
                self._user = nfn["User"]
                self._time = update_time
                self._status = nfn.get("Status", None)
                self._status_text = nfn["Status-Text"]

                return 1
        
        return 0


    def get_name(self):
        return self._user


    def get_status_text(self):
        return self._status_text


    def get_last_update(self):

        # calculate time
        status_bits = time.localtime(self._time)
        now_bits = time.localtime(time.time())
        midnight = time.mktime((now_bits[0], now_bits[1], now_bits[2], 0,0,0, 0,0,-1))

        if self._time > midnight:
            offset = "today"
        elif self._time < midnight and self._time >= (midnight - 86400):
            offset = "yesterday"
        else:
            offset = "%u days ago" % (int((midnight - self._time) / 86400.0) + 1)

        hour = status_bits[3]
        if hour > 11:
            xm = "pm"
            if hour >= 13:
                hour = hour - 12
        else:
            xm = "am"
            
        update_time = "% u:%02u%s %s" % (hour, status_bits[4], xm, offset)

        return update_time


#############################################################################

class EPMConnectionListener(elvin.ConnectionListener):
    """ """

    def __init__(self, epm):
        self._epm = epm
        self._url = None
        
    def established(self, connection, rock):
        self._url = None
        self._epm._sb.push(self._epm._sb_ctx,
                           "Connected to: %s" % \
                           connection.get_current_router_url().canonical())

    def lost(self, connection, rock):
        print "Status: lost connection."

    def attempt(self, connection, url, rock):
        self._url = url

    def attempt_failed(self, connection, url, error, rock):
        self._epm._sb.push(self._epm._sb_ctx,
                           "Connection to %s failed (%u)" % \
                           (self._url.canonical(),
                            connection.get_current_retry_count()))

    def packets_dropped(self, connection, rock):
        print "Status: Packets dropped."

    def max_retries(self, connection, retries, rock):
        self._epm._sb.push(self._epm._sb_ctx, "Reconnection failed!")

    def protocol_error(self, connection, rock):
        print "Status: Protocol error."

    def reply_timeout(self, connection, rock):
        print "Status: Reply timed out."


#############################################################################

class EPM(gtk.GtkWindow):
    """ """
    
    def __init__(self):
        """ """

        # initialise state
        self._urls = []           # URLs for Elvin routers
        self._scope = None        # Elvin router scope
        self._user = None         # user name, no domain
        self._domain = None       # user's default domain
        self._groups_file = None  # user's ticker groups file

        self._groups = None       # user's groups
        self._sub_users = None    # users for which the user wants status info
        self._sub_groups = None   # groups for which the user wants status info
        self._statuses = None     # list of additional status names
        
        self._ticker_groups = ""  # string list of subscribed tickertape groups

        self._buddies = {}        # record of buddies' statuses

        s = sha.new()
        s.update("%f %f" % (time.time(), random.random()))
        self._id = s.hexdigest()  # Client-ID

        # read config file, if there is one
        cfile = "%s/.epm" % os.environ.get("HOME", "/")
        if os.path.exists(cfile):
            f = open(cfile)
            s = f.read()
            f.close()

            #fixme: naughty, naughty
            exec(s)

        # set default values
        self._user = USER
        self._domain = DOMAIN
        self._groups = GROUPS
        self._sub_users = SUB_USERS
        self._sub_groups = SUB_GROUPS
        self._statuses = DEFAULT_STATUS + STATUS

        # parse command line args
        argv = sys.argv[1:]
        while len(argv):
            arg = argv.pop(0)

            if arg == "-e":
                self._urls.append(argv.pop(0))
            elif arg[:8] == "--elvin=":
                self._urls.append(arg[8:])

            elif arg == "-S":
                self._scope = argv.pop(0)
            elif arg[:8] == "--scope=":
                self._scope = arg[8:]

            elif arg == "-u":
                self._user = argv.pop(0)
            elif arg[:7] == "--user=":
                self._user = arg[7:]

            elif arg == "-D":
                self._domain = argv.pop(0)
            elif arg[:9] == "--domain=":
                self._domain = arg[9:]

            elif arg == "-G":
                self._groups_file = argv.pop(0)
            elif arg[:9] == "--groups=":
                self._groups_file = arg[9:]

            elif arg in ("-d", "--daemon"):
                self._daemon = 1

            elif arg in ("-v", "--version"):
                print RELEASE
                sys.exit(0)

            elif arg in ("-h", "-H", "-?", "--help"):
                self.usage()
                sys.exit(0)
                
            else:
                self.usage()
                sys.exit(1)

        # search environment for undefined things
        if not self._urls and os.environ.has_key("ELVIN_URL"):
            self._urls.append(os.environ["ELVIN_URL"])

        if not self._urls and not self._scope and os.environ.has_key("ELVIN_SCOPE"):
            self._scope = os.environ["ELVIN_SCOPE"]

        if not self._user and os.environ.has_key("USER"):
            self._user = os.environ["USER"]
            
        if not self._user and os.environ.has_key("LOGNAME"):
            self._user = os.environ["LOGNAME"]

        if not self._domain and os.environ.has_key("DOMAIN"):
            self._domain = os.environ["DOMAIN"]

        # validate args settings
        if self._groups_file and not os.path.exists(self._groups_file):
            self.usage()
            sys.exit(1)

        # debugging: print args 
        if 0:
            print self._urls
            print self._scope
            print self._user
            print self._domain
            print self._groups_file
            print
            print self._groups
            print self._sub_users
            print self._sub_groups
                
            sys.exit(0)

        # parse groups file
        parser = GroupsParser()
        groups = parser.parse(self._groups_file)
        self._ticker_groups = reduce(lambda l,i:l+i+"|",
                                     map(lambda i:i._name, self._ticker_groups),
                                     "|")
        
        # connect to Elvin router
        self._client = elvin.client(elvin.GtkLoop)
        self._elvin = self._client.connection()

        for url in self._urls:
            self._elvin.append_url(url)

        if self._scope:
            self._elvin.set_scope(self._scope)

        self._elvin.add_connection_listener(EPMConnectionListener(self))

        # initialise window
        gtk.GtkWindow.__init__(self, type=gtk.WINDOW_TOPLEVEL, title="epm")
        self.set_default_size(400, 300)
        
        vbox = gtk.GtkVBox()
        vbox.show()
        self.add(vbox)

        sw = gtk.GtkScrolledWindow()
        sw.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
        sw.show()
        vbox.pack_start(sw, fill=gtk.TRUE, expand=gtk.TRUE)

        # status list
        self._clist = gtk.GtkCList(3, ["User", "Time", "Status"])
        self._clist.show()
        self._clist.column_titles_passive()
        self._clist.set_sort_column(0)
        self._clist.set_column_width(0, 150)
        self._clist.set_column_width(1, 150)
        #self._clist.set_column_justification(1, gtk.JUSTIFY_RIGHT)
        self._clist.set_column_width(2, 200)
        sw.add(self._clist)

        # status dropdown
        self._status = gtk.GtkCombo()
        self._status.set_popdown_strings(self._statuses)
        self._status.set_value_in_list(gtk.FALSE, gtk.FALSE)
        self._status.set_use_arrows_always(gtk.TRUE)
        self._status.show()
        vbox.pack_start(self._status, fill=gtk.FILL_X, expand=gtk.FALSE)
        
        # button box
        bbox = gtk.GtkHButtonBox()
        bbox.set_border_width(10)
        bbox.show()
        vbox.pack_start(bbox, fill=gtk.FILL_X, expand=gtk.FALSE)

        b_set = gtk.GtkButton('Set')
        b_set.show()
        bbox.pack_start(b_set, fill=gtk.FALSE, expand=gtk.TRUE, padding=5)
        b_set.connect('button_press_event', self.do_set)

        b_remove = gtk.GtkButton('Remove')
        b_remove.show()
        bbox.pack_start(b_remove, fill=gtk.FALSE, expand=gtk.TRUE, padding=5)
        b_remove.connect('button_press_event', self.do_remove)

        b_refresh = gtk.GtkButton('Refresh')
        b_refresh.show()
        bbox.pack_start(b_refresh, fill=gtk.FALSE, expand=gtk.TRUE, padding=5)
        b_refresh.connect('button_press_event', self.do_refresh)

        b_close = gtk.GtkButton('Exit')
        b_close.show()
        bbox.pack_start(b_close, fill=gtk.FALSE, expand=gtk.TRUE, padding=5)
        b_close.connect('button_press_event', self.do_close)

        # status bar
        self._sb = gtk.GtkStatusbar()
        self._sb_ctx = self._sb.get_context_id("foo")
        self._sb.push(self._sb_ctx, "Connecting ...")
        self._sb.set_border_width(5)
        self._sb.show()
        vbox.pack_start(self._sb, fill=gtk.FILL_X, expand=gtk.FALSE)

        # launch midnight time updates
        now = time.time()
        tomorrow = now + 86400
        bits = time.localtime(tomorrow)
        midnight = time.mktime((bits[0], bits[1], bits[2], 0, 0, 0, 0, 0, -1))
        self._elvin.add_timeout(midnight - now, self.rollover, None)

        # initiate connection to elvin
        self._elvin.add_timeout(1, self.connect, None)

        # show gui
        self.show()

        # loop forever
        gtk.mainloop()
        #self._elvin.run()
        
        sys.exit()
        
        return


    def usage(self):
        """Print usage message."""

        sys.stderr.write(USAGE)
        sys.stderr.flush()
        return


    def connect(self, timeout, rock):
        """ """

        gtk.threads_enter()
        
        # connect to elvin
        try:
            self._elvin.open()

        except:
            print "Connection to Elvin router failed."
            sys.exit(1)

        if self._elvin.is_open():
            
            # subscribe for Presence-Info from others
            s = 'require(Presence-Info) && ('

            s = s + 'contains(fold-case(Groups), "|%s|"' % self._domain
            for group in self._sub_groups:
                s = s + ', "|%s|"' % group.lower()
            s = s + ')'
            
            if self._sub_users:
                s = s + ' || equals(fold-case(User)'
                for user in self._sub_users:
                    s = s + ', "%s"' % user.lower()
                s = s + ')'
                
            s = s + ')'

            #print
            #print s
            
            self._sub_info = self._elvin.subscribe(s, 1, None)
            self._sub_info.add_listener(self.handle_presence_info)
            self._sub_info.register()

            # subscribe for Presence-Requests from others
            s = 'require(Presence-Request) && (contains(fold-case(Users), "|%s@%s|") ' % \
                (self._user.lower(), self._domain.lower())
            s = s + '|| contains(fold-case(Groups), "|%s|"' % self._domain.lower()
            for group in self._groups:
                s = s + ', "|%s|"' % group.lower()
            s = s + '))'
            
            #print
            #print s
            
            self._sub_rqst = self._elvin.subscribe(s, 1, None)
            self._sub_rqst.add_listener(self.handle_presence_rqst)
            self._sub_rqst.register()

            # advertise initial status
            self._change_time = time.time()

            self.advertise()

            # request info from buddies
            self.request(self._sub_users, self._sub_groups)

        gtk.threads_leave()
        return 


    def do_set(self, button, event):
        """Set your status."""

        status = self._status.entry.get_text()
        if status not in self._statuses:
            self._statuses.append(status)
            self._status.set_popdown_strings(self._statuses)
            self._status.entry.set_text(status)

        self._change_time = time.time()
        self.update()
        return

    
    def advertise(self):
        """Advertise your initial presence status."""

        self._send_info("initial", "online",
                        self._status.entry.get_text(),
                        int(time.time() - self._change_time))
        return


    def update(self):
        """Update your presence status."""

        self._send_info("update", "online",
                        self._status.entry.get_text(),
                        int(time.time() - self._change_time))
        return


    def handle_presence_rqst(self, sub, nfn, insec, rock):
        """Handle request for our presence status."""

        self._send_info(nfn["Presence-Request"], "online",
                        self._status.entry.get_text(),
                        int(time.time() - self._change_time))
        return


    def do_remove(self, button, event):
        """Remove a buddy from the list"""

        while len(self._clist.selection) > 0:
            row = self._clist.selection[0]
            name = self._clist.get_text(row, 0)
            del self._buddies[name]
            self._clist.remove(row)
        
        return

    def do_refresh(self, button, event):
        """Send a request to all buddies"""
        
        self.request(self._sub_users, self._sub_groups)
        
        return

    def do_close(self, button, event):

        if self._elvin.is_open():
            self._send_info("update", "offline", "[epm client shutdown]", 0)

        # use exit not mainquit in case we're in a nested mainloop
        sys.exit(0)
        return


    def _send_info(self, xid, status, text, duration):
        """(Internal) Send Presence-Info notification."""

        m = elvin.message()
        m["Presence-Protocol"] = PROTOCOL_VERSION
        m["Client-Id"] = self._id
        m["User-Agent"] = "epm v%s (pe-%s/python-%d.%d/%s)" % \
                          (RELEASE,
                           elvin.config.release,
                           sys.version_info[0],
                           sys.version_info[1],
                           os.name == "nt" and os.name or "%s-%s" % (os.uname()[0], os.uname()[2]))
        
        m["User"] = "%s@%s" % (self._user, self._domain)
        m["Groups"] = self._groups and reduce(lambda l,i:l+i+"|", self._groups, "|") or ""
        m["Presence-Info"] = xid
        
        if xid != "update":
            if self._ticker_groups != "|":
                m["Chat-Groups"] = self._ticker_groups
            if 0:
                m["News-Groups"] = ""
            m["Ticker-Client"] = "generic"

        m["Status"] = status
        m["Status-Text"] = text
        m["Status-Duration"] = duration

        self._elvin.notify(m)
        return


    def request(self, users, groups):
        """Request status from buddies."""
        #
        #  requestor is optional in the spec, but we always send it

        m = elvin.message()
        m["Presence-Request"] = sha.new(str(time.time()) + str(os.getpid())).hexdigest()
        m["Presence-Protocol"] = 1000
        m["Requestor"] = "%s@%s" % (self._user, self._domain)
        m["Groups"] = groups and reduce(lambda l,i:l+i+"|", groups, "|") or ""
        m["Users"] = users and reduce(lambda l,i:l+i+"|", users, "|") or ""
        self._elvin.notify(m)
        return
        
        
    def handle_presence_info(self, sub, nfn, insec, rock):
        """Handle advertised presence info for one of our subscribers."""

        name = nfn["User"]

        if self._buddies.has_key(name):
            # update existing record
            buddy = self._buddies[name]

            if buddy.update(nfn):
                self.set_buddy(name, buddy.get_last_update(), buddy.get_status_text())

        else:
            # create new buddy record
            buddy = PresenceInfo(nfn)
            self._buddies[name] = buddy
            
            self.set_buddy(name, buddy.get_last_update(), buddy.get_status_text())

        return


    def set_buddy(self, name, update, status):
        
        row = -1
        for i in range(self._clist.rows):
            if self._clist.get_text(i, 0) == name:
                row = i
                break

        if row == -1:
            self._clist.append((str(name), update, str(status)))

        else:
            self._clist.set_text(row, 1, update)
            self._clist.set_text(row, 2, status)

        return


    def rollover(self, timeout, rock):
        """Roll update times over to new day."""

        # update UI
        for buddy in self._buddies.values():
            self.set_buddy(buddy.get_name(), buddy.get_last_update(), buddy.get_status_text())

        # launch midnight time updates
        now = time.time()
        tomorrow = now + 86400
        bits = time.localtime(tomorrow)
        midnight = time.mktime((bits[0], bits[1], bits[2], 0, 0, 0, 0, 0, -1))
        self._elvin.add_timeout(midnight - now, self.rollover, None)

        return

        
########################################################################

class ChatGroup:
    def __init__(self):
        self._name = ""
        self._menu = 0
        self._auto = 0
        self._min = -1
        self._max = -1


########################################################################

class GroupsParser:
    """ """

    def __init__(self):
        """ """

        return


    def parse(self, file=None):
        """ """

        groups = []
        
        if not file:
            file = "%s/.ticker/groups" % os.environ.get("HOME", "")

        try:
            f = open(file)
        except:
            return groups

        while 1:
            line = f.readline()
            if not line:
                break

            elif len(line.strip()) == 0 or line.strip()[0] == "#":
                continue

            bits = line.split(":")
            if len(bits) < 5:
                raise ParseError(line)

            g = ChatGroup()
            g._min = int(bits[3])
            g._max = int(bits[4])
            g._auto = bits[2].lower() == "auto"
            g._menu = bits[1].lower() == "menu"
            g._name = bits[0]

            groups.append(g)

        f.close()

        return groups
            


########################################################################

if __name__ == "__main__":
    EPM()
    

########################################################################
# Local Variables:
# mode: python
# End:
########################################################################
# end of epm
